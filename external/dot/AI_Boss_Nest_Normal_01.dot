digraph {
	fixedsize=true;
	concentrate=true;
	node [shape=rect margin="0.25,0.125"];
	start [shape=invhouse];

	node [style=filled fillcolor="#FFEEBB"]; # cond
	cond0_0 [tooltip="pos?pos=3|4"]; # middle front or center
	cond0_1 [tooltip="check?type=buff&kind=self&buff=Effect_MP_Nest_B07_5"]; # has Effect_MP_Nest_B07_5 buff in self
	cond_a0 [tooltip="check?type=buff&kind=self&buff=Effect_MP_Nest_B07_33,random?op=ebigger&value=30"]; # has Effect_MP_Nest_B07_33 buff in self and 70% chance
	cond_a1 [tooltip="check?type=buff&kind=self&buff=Effect_MP_Nest_B07_34,random?op=ebigger&value=55"]; # has Effect_MP_Nest_B07_34 buff in self and 45% chance
	cond_a2 [tooltip="check?type=buff&kind=self&buff=Effect_MP_Nest_B07_35,random?op=ebigger&value=70"]; # has Effect_MP_Nest_B07_35 buff in self and 30% chance
	cond3 [tooltip="random?op=ebigger&value=30"]; # 70% chance
	skill_usable1 [tooltip="check?type=skill&slot=1&kind=usable"]; # active 1 usable
	skill_usable2 [tooltip="check?type=skill&slot=2&kind=usable"]; # active 1 usable
	usable_cell1 [tooltip="check?type=skill&slot=1&kind=movable"]; # is cell exists that can use active 1
	usable_cell2 [tooltip="check?type=skill&slot=2&kind=movable"]; # is cell exists that can use active 2

	node [fillcolor="#BBCCFF"];
	skill1 [tooltip="skill?slot=1&target=atkhighest"]; # use active 1 to highest atk first
	skill2 [tooltip="skill?slot=2&target=near"]; # use active 2 to near first

	node [fillcolor="#7788aa"];
	move1 [tooltip="move?slot=1"]; # move to cell that can use active 1
	move2 [tooltip="move?slot=2"]; # move to cell that can use active 2
	move_4 [tooltip="move?pos=4"]; # move to center
	wait [tooltip="wait" fillcolor="#999999"]; # wait

	start -> cond0_0;

	cond0_0 -> cond0_1 [label="y"];
	cond0_0 -> cond3 [label="n"];

	cond3 -> move_4 [label="y"];
	cond3 -> skill_usable2 [label="n"];

	cond0_1 -> skill_usable1 [label="y"];
	cond0_1 -> cond_a0 [label="n"];

	cond_a0 -> skill_usable2 [label="y"];
	cond_a0 -> cond_a1 [label="n"];

	cond_a1 -> skill_usable2 [label="y"];
	cond_a1 -> cond_a2 [label="n"];

	cond_a2 -> skill_usable2 [label="y"];
	cond_a2 -> skill_usable1 [label="n"];

	skill_usable2 -> skill2 [label="y"];
	skill_usable2 -> usable_cell2 [label="n"];

	usable_cell2 -> move2 [label="y"];
	usable_cell2 -> wait [label="n"];

	skill_usable1 -> skill1 [label="y"];
	skill_usable1 -> usable_cell1 [label="n"];

	usable_cell1 -> move1 [label="y"];
	usable_cell1 -> wait [label="n"];
}